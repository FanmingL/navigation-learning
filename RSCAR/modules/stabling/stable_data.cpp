//// Created by erdou on 18-11-1.//#include "stable_data.h"namespace rs{    namespace vp{        stable_data::stable_data(const std::string &name) : rs(name) , count(0){            ReadData();            video_capture.open(common::GetAbsolutePath(stabling_config.in_video_path()));            max_rect = cv::Rect2d(0,0,video_capture.get(CV_CAP_PROP_FRAME_WIDTH), video_capture.get(CV_CAP_PROP_FRAME_HEIGHT));            std::remove(common::GetAbsolutePath(stabling_config.out_video_path()).c_str());            video_writer.open(common::GetAbsolutePath(stabling_config.out_video_path()),CV_FOURCC('D', 'I', 'V', 'X'),30,max_rect.size());            step = stabling_config.step_count();            init();        }        void stable_data::Run() {            cv::Mat dst, canvas;            while (true){                video_capture >> frame;                if (frame.empty())break;                auto detect_frame = detect_in_data.frame(count + 1);                cv::warpPerspective(frame,dst,homograph_vector[count],frame.size());                video_writer << dst;                canvas = dst.clone();                auto *iter = detect_out_data.add_frame();                for (auto &item : detect_frame.object()){                    auto *iter2 = iter->add_object();                    iter2->set_probility(item.probility());                    iter2->set_name(item.name());                    cv::Rect2f rect((item.x() - item.width()/2) *max_rect.width,                                    (item.y() - item.height()/2) * max_rect.height,                                    item.width() * max_rect.width,                                    item.height() * max_rect.height);                    cv::Point2f tl, br;                    common::CalculateTransform(homograph_vector[count],rect.tl(),tl,2);                    common::CalculateTransform(homograph_vector[count],rect.br(),br,2);                    rect = cv::Rect2f(tl, br);                    cv::rectangle(canvas, rect, cv::Scalar(255,0,0),2);                    iter2->set_x(rect.x);                    iter2->set_y(rect.y);                    iter2->set_width(rect.width);                    iter2->set_height(rect.height);                }                cv::imshow("111", canvas);                if (cv::waitKey(1)=='q')break;                AddCount();            }            common::WriteProtoToBinaryFile(stabling_config.new_data_path(), &detect_out_data);        }        void stable_data::ReadData() {            common::ReadProtoFromTextFile("modules/stabling/config/stabling.prototxt", &stabling_config);            common::ReadProtoFromBinaryFile(stabling_config.out_data_path(), &homograph_video);            common::ReadProtoFromBinaryFile(stabling_config.in_data_path(), &detect_in_data);        }        void stable_data::AddCount() {            std::cout<<count++<<std::endl;        }        void stable_data::init() {            video_capture >> frame;            video_writer << frame;            auto *iter = detect_out_data.add_frame();            for (auto &item : detect_in_data.frame(0).object()){                auto *iter2 = iter->add_object();                iter2->set_name(item.name());                iter2->set_width(item.width() * max_rect.width);                iter2->set_height(item.height() * max_rect.height);                iter2->set_x((item.x() - item.width()/2) * max_rect.width );                iter2->set_y((item.y() - item.height()/2) * max_rect.height);                iter2->set_probility(item.probility());            }            for (auto & item : homograph_video.matrix()){                homograph_vector.push_back(GetdoubleMatrix(item));            }            for (int i = 0; i < homograph_vector.size() - step;++i){                //std::cout<<homograph_vector[i]<<std::endl;                for (int ii = 1; ii <= (step) ; ++ii){                    homograph_vector[ii + i] = homograph_vector[i] +                            (homograph_vector[i + step + 1] - homograph_vector[i]) / ((float)(step+1)) * ii;                }                i+=step;            }        }        cv::Mat stable_data::GetFloatMatrix(const HomographMatrix &data) {            cv::Mat res(3,3,CV_32FC1, cv::Scalar(0));            res.at<float>(0, 0) = data.h11();            res.at<float>(0, 1) = data.h12();            res.at<float>(0, 2) = data.h13();            res.at<float>(1, 0) = data.h21();            res.at<float>(1, 1) = data.h22();            res.at<float>(1, 2) = data.h23();            res.at<float>(2, 0) = data.h31();            res.at<float>(2, 1) = data.h32();            res.at<float>(2, 2) = data.h33();            return res;        }        cv::Mat stable_data::GetdoubleMatrix(const HomographMatrix &data) {            cv::Mat res(3,3,CV_64FC1, cv::Scalar(0));            res.at<double>(0, 0) = data.h11();            res.at<double>(0, 1) = data.h12();            res.at<double>(0, 2) = data.h13();            res.at<double>(1, 0) = data.h21();            res.at<double>(1, 1) = data.h22();            res.at<double>(1, 2) = data.h23();            res.at<double>(2, 0) = data.h31();            res.at<double>(2, 1) = data.h32();            res.at<double>(2, 2) = data.h33();            return res;        }    }}MAIN(rs::vp::stable_data, "stable data");